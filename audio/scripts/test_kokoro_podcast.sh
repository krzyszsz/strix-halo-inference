#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

docker() {
  if [ "$(id -u)" -ne 0 ]; then
    sudo docker "$@"
  else
    command docker "$@"
  fi
}

IMAGE="${IMAGE:-local-audio-tools:latest}"
VOICE="${VOICE:-af_heart}"
SPEED="${SPEED:-1.0}"
LANG_CODE="${LANG_CODE:-a}"
INPUT_TEXT="${INPUT_TEXT:-$REPO_ROOT/audio/input/podcast_script.txt}"
OUT_DIR="$REPO_ROOT/audio/out"
OUT_WAV="${OUT_WAV:-$OUT_DIR/podcast_kokoro_best_retest.wav}"
OUT_SUMMARY="${OUT_SUMMARY:-$OUT_DIR/podcast_kokoro_best_retest_summary.json}"
MEM_LIMIT="${MEM_LIMIT:-75g}"
MEMORY_SWAP="${MEMORY_SWAP:-75g}"
MEM_RESERVATION="${MEM_RESERVATION:-67g}"
OOM_SCORE_ADJ="${OOM_SCORE_ADJ:-500}"

mkdir -p "$OUT_DIR"

if [ ! -f "$INPUT_TEXT" ]; then
  echo "Missing transcript file: $INPUT_TEXT" >&2
  exit 1
fi

TMP_PY="$(mktemp "${TMPDIR:-/tmp}/kokoro_tts.XXXXXX.py")"
trap 'rm -f "$TMP_PY"' EXIT

cat <<'PY' > "$TMP_PY"
import json
import os
from pathlib import Path

import numpy as np
import soundfile as sf
from kokoro import KPipeline


def split_paragraphs(text: str) -> list[str]:
    chunks = [c.strip() for c in text.split("\n\n")]
    return [c for c in chunks if c]


input_path = Path(os.environ["INPUT_TEXT"])
out_wav = Path(os.environ["OUT_WAV"])
out_summary = Path(os.environ["OUT_SUMMARY"])
voice = os.environ.get("VOICE", "af_heart")
speed = float(os.environ.get("SPEED", "1.0"))
lang_code = os.environ.get("LANG_CODE", "a")

text = input_path.read_text(encoding="utf-8")
chunks = split_paragraphs(text)

pipeline = KPipeline(lang_code=lang_code)
all_audio = []
sample_rate = 24000

for chunk in chunks:
    for _, _, audio in pipeline(chunk, voice=voice, speed=speed):
        audio = np.asarray(audio, dtype=np.float32)
        if audio.size == 0:
            continue
        all_audio.append(audio)
        # Short pause between generated spans for podcast pacing.
        all_audio.append(np.zeros(int(sample_rate * 0.35), dtype=np.float32))

if not all_audio:
    raise RuntimeError("No audio generated by Kokoro pipeline")

final_audio = np.concatenate(all_audio, axis=0)
out_wav.parent.mkdir(parents=True, exist_ok=True)
sf.write(str(out_wav), final_audio, sample_rate)

summary = {
    "input_text": str(input_path),
    "voice": voice,
    "speed": speed,
    "lang_code": lang_code,
    "chunks": len(chunks),
    "sample_rate": sample_rate,
    "samples": int(final_audio.shape[0]),
    "duration_seconds": round(float(final_audio.shape[0]) / sample_rate, 2),
    "output_wav": str(out_wav),
}
out_summary.write_text(json.dumps(summary, indent=2), encoding="utf-8")
print(json.dumps(summary, indent=2))
PY

docker run --rm \
  --memory="$MEM_LIMIT" \
  --memory-swap="$MEMORY_SWAP" \
  --memory-reservation="$MEM_RESERVATION" \
  --oom-score-adj="$OOM_SCORE_ADJ" \
  -v "$REPO_ROOT:$REPO_ROOT:Z" \
  -v "$TMP_PY:/tmp/kokoro_tts.py:Z" \
  -w "$REPO_ROOT" \
  -e INPUT_TEXT="$INPUT_TEXT" \
  -e OUT_WAV="$OUT_WAV" \
  -e OUT_SUMMARY="$OUT_SUMMARY" \
  -e VOICE="$VOICE" \
  -e SPEED="$SPEED" \
  -e LANG_CODE="$LANG_CODE" \
  --entrypoint python \
  "$IMAGE" \
  -u /tmp/kokoro_tts.py

if [ -f "$OUT_WAV" ] && [ ! -w "$OUT_WAV" ]; then
  sudo chown "$(id -u):$(id -g)" "$OUT_WAV" || true
fi
if [ -f "$OUT_SUMMARY" ] && [ ! -w "$OUT_SUMMARY" ]; then
  sudo chown "$(id -u):$(id -g)" "$OUT_SUMMARY" || true
fi
